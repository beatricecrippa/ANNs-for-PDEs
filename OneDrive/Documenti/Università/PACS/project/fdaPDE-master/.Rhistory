output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP22<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 4.2.3: Forcing term != 0 grid with stochastic GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP23<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
#### Test 4.2.4: Forcing term != 0 Newton finite differences with exact GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP24<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 4.2.5: Forcing term != 0 Newton finite differences with stochastic GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP25<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
#### Test 4.3.1: BC != 0      without GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters)
data=data_backup #restore original data for next tests
#### Test 4.3.2: BC != 0      grid with exact GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP26<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP27<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP28<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
#### Test 4.3.5: BC != 0     Newton Finite differences with stochastic GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP29<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
# plot(output_CPP$fit.FEM)
install.packages("fdaPDE")
load("~/test1.RData")
#### Test 1: square domain ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
library(fdaPDE)
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# Test function
f = function(x, y, z = 1)
{
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact = f(mesh$nodes[,1], mesh$nodes[,2])
# Add error to simulate data
set.seed(7893475)
ran = range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-6,-3,by=0.25)
#### Test 1.1: Without GCV
aoutput_CPP1<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
#### Test 1.2: grid with exact GCV
aoutput_CPP2<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 1.3: grid with stochastic GCV
aoutput_CPP3<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV', DOF.stochastic.realizations = 1000)
### Test 1.4: Newton exact method with exact GCV, default initial lambda and tolerance
aoutput_CPP4<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.5: Newton_fd method with  exact GCV, default initial lambda and tolerance
aoutput_CPP5<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
aoutput_CPP6<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
load("~/fpca.RData")
library(fdaPDE)
#### Test 1: 2D square domain ####
#            locations = nodes
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc3=FEM(cos(2*pi*mesh$nodes[,2]), FEMbasis)
plot(eigenfunc1)
plot(eigenfunc2)
plot(eigenfunc3)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff))
truecoeff<-cbind(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff)
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_score3<-0.03
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
score3<-rnorm(n=nSamples,sd=sd_score3*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))+matrix(score3)%*%t(matrix(eigenfunc3$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
nnodes=dim(mesh$nodes)[1]
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 1.1: Without GCV
lambda = 10^-2
sol.pointwise1<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=3)
# plot(sol.pointwise$loadings.FEM)
#### Test 1.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
sol.pointwise2<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='KFold',GCVmethod='Stochastic')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 1.3: K-Fold validation - Exact
sol.pointwise3<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='KFold',GCVmethod='Exact')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 1.4: GCV validation - Stochastic
sol.pointwise4<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Stochastic')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 1.5: GCV validation - Exact
sol.pointwise5<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Exact')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
save.image("~/fpca.RData")
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(sphere2.5D)
mesh<-create.mesh.2.5D(sphere2.5D$nodes, sphere2.5D$triangles)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
plot(eigenfunc1)
plot(eigenfunc2)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff))
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 3.1: Without GCV
lambda = 10^-2
sol.pointwise11<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=2)
# plot(sol.pointwise$loadings.FEM)
#### Test 3.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
sol.pointwise12<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Stochastic')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 3.3: K-Fold validation - Exact
sol.pointwise13<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Exact')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 3.4: GCV validation - Stochastic
sol.pointwise14<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='GCV',GCVmethod='Stochastic')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 3.5: GCV validation - Exact
sol.pointwise15<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Exact')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 4: 3D sphere domain ####
#            locations = nodes
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(sphere3Ddata)
mesh = create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
plot(eigenfunc1)
plot(eigenfunc2)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff))
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 4.1: Without GCV
lambda = 10^-2
asol.pointwis16e<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=2)
# plot(sol.pointwise$loadings.FEM)
#### Test 4.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
asol.pointwise17<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Stochastic')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 4.3: K-Fold validation - Exact
asol.pointwise18<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Exact')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 4.4: GCV validation - Stochastic
asol.pointwise19<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='GCV',GCVmethod='Stochastic')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
#### Test 4.5: GCV validation - Exact
asol.pointwise20<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='GCV',GCVmethod='Exact')
# plot(sol.pointwise$loadings.FEM)
# sol.pointwise$lambda
save.image("~/fpca.RData")
load("~/de.RData")
##########################################
############## TEST SCRIPT ###############
######## for DENSITY ESTIMATION ##########
##########################################
library(fdaPDE)
# 2D ------------------
library(fdaPDE)
# rm(list=ls())
graphics.off()
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
## Density Estimation:
# 1) Cross-validation
lambda = c(0.001, 0.01, 0.1, 1)
nfolds = 5
asol1 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="RightCV")
# sol$lambda
## Visualization
# image(FEM(exp(sol$g), FEMbasis))
## Visualization on a fine grid
# n = 100
# X <- seq(-3, 3, length.out = n)
# Y<- seq(-3, 3, length.out = n)
# grid <- expand.grid(X, Y)
# evaluation <- eval.FEM(FEM(FEMbasis, coeff = sol$g), locations = grid)
# evaluation <- exp(evaluation)
# eval <- matrix(evaluation, n, n)
# image2D(x=X, y=Y, z=eval, col=heat.colors(100), xlab="x",ylab="y", contour=list(drawlabels = FALSE), main = "Estimated density")
# 2) Lambda fixed
lambda = 0.1
asol2 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 3) Cross-validation simplified version
lambda = c(0.0001, 0.001, 0.01, 0.1, 1)
nfolds = 5
asol3 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="SimplifiedCV")
# sol$lambda
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 4) Initialization given
lambda = 0.1
initF = rep(1, nrow(mesh$nodes))
asol4 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec = initF,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 5) step_method = Backtracking method
lambda = 0.1
asol5 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Backtracking_Method", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 6) step_method = Wolfe method
lambda = 0.1
asol6 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Wolfe_Method", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 7) direction_method = Gradient
lambda = 0.1
asol7 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "Gradient",
preprocess_method="NoCrossValidation")
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 8) Naive search algorithm
lambda = 0.1
asol8 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation", search = "naive")
# ## Visualization
# image(FEM(exp(sol$g), FEMbasis))
# 2.5D -------------
library(fdaPDE)
# rm(list=ls())
## Create a 2.5D mesh
data(sphere2.5D)
sphere<-create.mesh.2.5D(sphere2.5D$nodes, sphere2.5D$triangles)
# Normalize the sphere
sum_square = sphere$nodes[,1]^2 + sphere$nodes[,2]^2 + sphere$nodes[,3]^2
sphere$nodes[,1] = sphere$nodes[,1]  / sqrt(sum_square)
sphere$nodes[,2] = sphere$nodes[,2]  / sqrt(sum_square)
sphere$nodes[,3] = sphere$nodes[,3]  / sqrt(sum_square)
FEMbasis <- create.FEM.basis(sphere)
## Generating data
library(Directional)
mu <- c(0, -1, 0)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
plot(sphere)
pch3d(data, pch=19, cex=0.1, col="red")
## Density Estimation:
lambda = 0.01
asol9 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda)
## Visualization
# plot(FEM(exp(sol$g), FEMbasis))
# plot(sphere)
# pch3d(data, pch=19, cex=0.1, col="red")
# pch3d(sol$data, pch=19, cex=0.1, col="blue")
# 3D -------------------------------------------
library(fdaPDE)
# rm(list=ls())
## Create a 3D mesh
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
## Generate data
fact = 0.01
n = 100
data_x <- fact*rnorm(n)
data_y <- fact*rnorm(n)
data_z <- fact*rnorm(n)
data <- cbind(data_x, data_y, data_z)
## Density Estimation:
lambda = 1e-5
asol10 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda)
## Visualization
# plot(FEM(exp(asol10$g), FEMbasis))
save.image("~/de.RData")
library(devtools)
devtools::check('C:/users/beacr/OneDrive/Documenti/Università/PACS/project/fdaPDE-master/fdaPDE')
devtools::check('C:/Users/beacr/OneDrive/Documenti/Università/PACS/project/fdaPDE-master/fdaPDE')
devtools::check('C:\Users\beacr\OneDrive\Documenti\Università\PACS\project\fdaPDE-master\fdaPDE')
setwd("~/Università/PACS/project/fdaPDE-master")
devtools::check('C:\Users\beacr\OneDrive\Documenti\Università\PACS\project\fdaPDE-master\fdaPDE')
devtools::check('fdaPDE')
devtools::check('fdaPDE_1.1-3.tar.gz')
setwd("~/Università/PACS/project/fdaPDE-master/fdaPDE")
devtools::check('.')
devtools::check(package='.')
check(fdaPDE)
check('.')
setwd("~/Università/PACS/project/fdaPDE-master")
check('fdaPDE-1.1-3.tar.gz')
check('fdaPDE_1.1-3.tar.gz')
